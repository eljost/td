#!/usr/bin/env python3

import logging
import os
import re
import sys

from jinja2 import Environment, FileSystemLoader
import pandas as pd

from td.helper_funcs import chunks, THIS_DIR

try:
    from docx import Document
except ImportError:
    pass

from td.tabulate import tabulate

__all__ = [
            "print_table",
            "as_table",
            "as_docx",
            "as_tiddly_table",
            "as_theodore",
            "as_booktabs",
            "as_dataframe",
]

def print_table(excited_states):
    as_list = [exc_state.as_list() for exc_state in excited_states]
    floatfmt = ["", "", "", "", ".2f", ".1f", ".5f", ""]
    print(tabulate(as_list,
                   headers=["# org.", "# sort.", "2S+1", "Spat.", "dE in eV",
                            "l in nm", "f", "<S**2>"],
                   floatfmt=floatfmt))

def as_table(excited_states, verbose_mos, newline_str="\n"):
    # The table header
    header = ("State",
              "λ / nm",
              "E / eV",
              "f",
              "Transition",
              "Weight")
    attrs = ("id", "l", "dE", "f")
    trans_fmt = "{} ({} {}) → {} ({} {})"
    weight_fmt = "{:.0%}"

    # Prepare the data to be inserted into the table
    as_lists = [es.as_list(attrs) for es in excited_states]
    as_fmt_lists = [[
        "S{}".format(id),
        "{:.1f}".format(l),
        "{:.2f}".format(dE),
        "{:.4f}".format(f)] for id, l, dE, f in as_lists]

    # For one excited state there may be several transitions
    # that contribute. This loop constructs two string, holding
    # the information about the transitions and the contributing
    # weights.
    for i, exc_state in enumerate(excited_states):
        mo_trans = exc_state.mo_transitions
        trans_str_list = list()
        # This loops over all MOTransitions for ONE excited state
        for mot in mo_trans:
            start_tpl = mot.start_tpl()
            final_tpl = mot.final_tpl()
            try:
                verbose_start_mo = verbose_mos[start_tpl]
                verbose_final_mo = verbose_mos[final_tpl]
            except:
                verbose_start_mo = ""
                verbose_final_mo = ""

            trans_str = trans_fmt.format(
                            verbose_start_mo,
                            mot.start_mo,
                            mot.start_irrep,
                            verbose_final_mo,
                            mot.final_mo,
                            mot.final_irrep)
            trans_str_list.append(trans_str)
        weight_list = [weight_fmt.format(mot.contrib)
                       for mot in mo_trans]
        weight_str = newline_str.join(weight_list)
        trans_str = newline_str.join(trans_str_list)
        as_fmt_lists[i].extend([trans_str, weight_str])

    return as_fmt_lists, header


def as_docx(excited_states, verbose_mos):
    """Export the supplied excited states into a .docx-document."""
    # Check if docx was imported properly. If not exit.
    if "docx" not in sys.modules:
        logging.error("Could't import python-docx-module.")
        sys.exit()

    docx_fn = "export.docx"
    as_fmt_lists, header = as_table(excited_states, verbose_mos)

    # Prepare the document and the table
    doc = Document()
    # We need one additional row for the table header
    table = doc.add_table(rows=len(excited_states)+1,
                          cols=len(header))

    # Set header in the first row
    for item, cell in zip(header, table.rows[0].cells):
        cell.text = item

    # Start from the 2nd row (index 1) and fill in all cells
    # with the parsed data.
    for i, fmt_list in enumerate(as_fmt_lists, 1):
        for item, cell in zip(fmt_list, table.rows[i].cells):
            cell.text = item
    # Save the document
    doc.save(docx_fn)


def as_tiddly_table(excited_states, verbose_mos):
    as_fmt_lists, header = as_table(excited_states,
                                    verbose_mos,
                                    newline_str="<br>")
    # Surround the numbers in S_i with ,, ,, so they are displayed
    # with subscript in tiddlywiki.
    header_line = "|! " + " |! ".join(header) + " |"
    data_lines = [
        "| " + " | ".join(exc_line) + " |" for exc_line
        in as_fmt_lists]
    print(header_line)
    for l in data_lines:
        print(l)


def as_theodore(excited_states, fn):
    """Combine the NTO-pictures generated by THEOdore/JMOl with
    the information parsed by td.py in a new .html-document."""
    # Search for  NTO-pictures in ./theodore
    pngs = [f for f in os.listdir("./theodore")
            if f.endswith(".png")]
    # Their naming follows the pattern
    # NTO{MO}{sym}_{pairNum}{o|v}_{weight}.png
    png_regex = "NTO(\d+)([\w'\"]+)_(\d+)(o|v)_([\d\.]+)\.png"
    parsed_png_fns = [re.match(png_regex, png).groups()
                      for png in pngs]
    # Convert the data to their proper types
    parsed_png_fns = [(int(state), irrep, int(pair), ov, float(weight))
                      for state, irrep, pair, ov, weight in parsed_png_fns]
    # Combine the data with the filenames of the .pngs
    zipped = [(p, *parsed_png_fns[i])
              for i, p in enumerate(pngs)]
    # Neglect NTOs below a certain threshold (20%)
    zipped = [nto for nto in zipped if nto[5] >= 0.2]
    # Sort by state, by weight, by pair  and by occupied vs. virtual
    zipped = sorted(zipped, key=lambda nto: (nto[2], nto[1], -nto[5],
                                             nto[3], nto[4]))
    assert((len(zipped) % 2) == 0)
    nto_dict = dict()
    for nto_pair in chunks(zipped, 2):
        onto, vnto = nto_pair
        assert(onto[2] == vnto[2])
        ofn, state, irrep, pair, ov, weight = onto
        vfn = vnto[0]
        key = (state, irrep)
        nto_dict.setdefault(key, list()).append((ofn, vfn, weight))

    j2_env = Environment(loader=FileSystemLoader(THIS_DIR,
                                                 followlinks=True))
    tpl = j2_env.get_template("templates/theo.tpl")
    # Only pass states to the template for which NTO pictures exist
    states = excited_states[:len(nto_dict)]

    states = sorted(states, key=lambda es: -es.l)
    # Update the ids of the states
    for id, s in enumerate(states, 1):
        s.id_sorted = id

    ren = tpl.render(states=states,
                     nto_dict=nto_dict,
                     fn=fn)
    with open("theo_comb.html", "w") as handle:
        handle.write(ren)


def as_booktabs(excited_states):
    as_list = [exc_state.as_list() for exc_state in excited_states]
    nr, mult, sym, eV, nm, f, spin = zip(*as_list)
    eV = ["{:.2f}".format(_) for _ in eV]
    f = ["{:.4f}".format(_) for _ in f]
    nm = ["{:.1f}".format(_) for _ in nm]
    for_booktabs = zip(nr, sym, eV, nm, f)
    print(tabulate(for_booktabs, tablefmt="latex_booktabs"))


def as_dataframe(excited_states):
    attrs = ("id", "l", "dE", "f")
    as_lists = [es.as_list(attrs) for es in excited_states]
    df = pd.DataFrame(as_lists, columns=attrs)
    return df
